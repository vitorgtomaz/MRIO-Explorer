<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MRIO Mini Calculator</title>
    <style>
      :root { font-family: Arial, sans-serif; color-scheme: light; }
      body { margin: 24px; max-width: 1100px; }
      h1 { margin-bottom: 8px; }
      .controls { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 16px; }
      label { font-size: 0.95rem; }
      input[type='number'] { width: 88px; padding: 4px; }
      button { padding: 8px 14px; cursor: pointer; }
      .matrix-wrap { overflow-x: auto; margin-bottom: 20px; }
      table { border-collapse: collapse; }
      td, th { border: 1px solid #c9c9c9; padding: 4px 6px; text-align: right; }
      th { background: #f3f4f6; }
      .matrix-input { width: 76px; }
      .results { display: grid; gap: 20px; }
      .card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; }
      .muted { color: #6b7280; font-size: 0.9rem; }
      .error { color: #b91c1c; font-weight: 600; }
      .ok { color: #065f46; font-weight: 600; }
    </style>
  </head>
  <body>
    <h1>MRIO Mini Calculator</h1>
    <p class="muted">Enter a square flow matrix (max 10x10). The app computes row-normalized A, a truncated Leontief series (I + A + ... + A^k), and the dominant eigenpair.</p>

    <section class="controls">
      <label>
        Dimension
        <input id="dimension" type="number" min="1" max="10" value="3" />
      </label>
      <label>
        Leontief order (k)
        <input id="order" type="number" min="0" max="40" value="12" />
      </label>
      <label>
        Max eigen iterations
        <input id="iterations" type="number" min="1" max="5000" value="200" />
      </label>
      <label>
        Eigen tolerance
        <input id="tolerance" type="number" min="0.0000000001" step="0.00000001" value="0.000001" />
      </label>
      <button id="resize">Resize Matrix</button>
      <button id="calculate">Run Calculations</button>
      <button id="sample">Load Sample</button>
    </section>

    <section>
      <h2>Flow Matrix (Z)</h2>
      <div class="matrix-wrap" id="matrixContainer"></div>
    </section>

    <section class="results">
      <div class="card">
        <h3>Status</h3>
        <div id="status" class="muted">Ready.</div>
      </div>
      <div class="card">
        <h3>Row-normalized matrix (A)</h3>
        <div class="matrix-wrap" id="normalizedOutput"></div>
      </div>
      <div class="card">
        <h3>Leontief series approximation</h3>
        <div class="muted" id="leontiefMeta"></div>
        <div class="matrix-wrap" id="leontiefOutput"></div>
      </div>
      <div class="card">
        <h3>Dominant eigenpair (power iteration)</h3>
        <div id="eigenMeta" class="muted"></div>
        <div class="matrix-wrap" id="eigenVectorOutput"></div>
      </div>
    </section>

    <script type="module">
      import { csrFromDense, denseFromCSR, transposeCSR } from './dist/engine/sparseOps.js';
      import { normalizeRows } from './dist/engine/normalizeRows.js';
      import { computeLeontiefSeries } from './dist/engine/leontief.js';
      import { computeDominantEigenpair } from './dist/engine/eigen.js';

      // --- DOM references ---
      const dimensionInput = document.getElementById('dimension');
      const orderInput = document.getElementById('order');
      const iterationsInput = document.getElementById('iterations');
      const toleranceInput = document.getElementById('tolerance');
      const matrixContainer = document.getElementById('matrixContainer');
      const statusEl = document.getElementById('status');
      const normalizedOutput = document.getElementById('normalizedOutput');
      const leontiefOutput = document.getElementById('leontiefOutput');
      const leontiefMeta = document.getElementById('leontiefMeta');
      const eigenMeta = document.getElementById('eigenMeta');
      const eigenVectorOutput = document.getElementById('eigenVectorOutput');

      function clampDimension(value) {
        if (!Number.isFinite(value)) return 1;
        return Math.max(1, Math.min(10, Math.floor(value)));
      }

      // --- UI helpers ---

      function replaceWithNode(container, node) {
        while (container.firstChild) container.removeChild(container.firstChild);
        container.appendChild(node);
      }

      function getValue(values, row, col) {
        if (!values || !values[row]) return 0;
        return values[row][col] ?? 0;
      }

      function renderMatrixInput(size, values) {
        const table = document.createElement('table');
        const header = document.createElement('tr');
        header.appendChild(document.createElement('th'));
        for (let c = 0; c < size; c += 1) {
          const th = document.createElement('th');
          th.textContent = `C${c + 1}`;
          header.appendChild(th);
        }
        table.appendChild(header);

        for (let r = 0; r < size; r += 1) {
          const tr = document.createElement('tr');
          const rowLabel = document.createElement('th');
          rowLabel.textContent = `R${r + 1}`;
          tr.appendChild(rowLabel);
          for (let c = 0; c < size; c += 1) {
            const td = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'matrix-input';
            input.dataset.row = String(r);
            input.dataset.col = String(c);
            input.value = String(getValue(values, r, c));
            td.appendChild(input);
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }

        replaceWithNode(matrixContainer, table);
      }

      function getMatrixValues() {
        const inputs = matrixContainer.querySelectorAll('input.matrix-input');
        let domSize = 0;
        inputs.forEach((input) => {
          domSize = Math.max(domSize, Number(input.dataset.row) + 1);
        });
        if (domSize === 0) {
          const size = clampDimension(Number(dimensionInput.value));
          return Array.from({ length: size }, () => Array(size).fill(0));
        }
        const matrix = Array.from({ length: domSize }, () => Array(domSize).fill(0));
        inputs.forEach((input) => {
          const row = Number(input.dataset.row);
          const col = Number(input.dataset.col);
          const value = Number(input.value);
          matrix[row][col] = Number.isFinite(value) ? value : 0;
        });
        return matrix;
      }

      function renderNumberMatrix(container, matrix, digits = 4) {
        const table = document.createElement('table');
        for (let r = 0; r < matrix.length; r += 1) {
          const tr = document.createElement('tr');
          for (let c = 0; c < matrix[r].length; c += 1) {
            const td = document.createElement('td');
            td.textContent = matrix[r][c].toFixed(digits);
            tr.appendChild(td);
          }
          table.appendChild(tr);
        }
        replaceWithNode(container, table);
      }

      function renderVector(container, vector, digits = 6) {
        const table = document.createElement('table');
        for (let i = 0; i < vector.length; i += 1) {
          const tr = document.createElement('tr');
          const name = document.createElement('th');
          name.textContent = `v${i + 1}`;
          const value = document.createElement('td');
          value.textContent = vector[i].toFixed(digits);
          tr.appendChild(name);
          tr.appendChild(value);
          table.appendChild(tr);
        }
        replaceWithNode(container, table);
      }

      // --- Calculation ---

      function runCalculations() {
        try {
          const denseMatrix = getMatrixValues();
          const order = Math.max(0, Math.floor(Number(orderInput.value) || 0));
          const maxIterations = Math.max(1, Math.floor(Number(iterationsInput.value) || 1));
          const tolerance = Number(toleranceInput.value);

          if (!Number.isFinite(tolerance) || tolerance <= 0) {
            throw new Error('Tolerance must be a positive number.');
          }

          const flowCSR = csrFromDense(denseMatrix);
          const normalizedCSR = normalizeRows(flowCSR);

          // Leontief: I + A + A² + ... + Aᵏ
          const leontief = computeLeontiefSeries(normalizedCSR, { order });

          // Left eigenvector (stationary distribution) via power iteration on Aᵀ,
          // which captures upstream structural importance in the supply chain.
          const eigen = computeDominantEigenpair(transposeCSR(normalizedCSR), { maxIterations, tolerance });

          renderNumberMatrix(normalizedOutput, denseFromCSR(normalizedCSR));
          renderNumberMatrix(leontiefOutput, denseFromCSR(leontief.matrix));
          renderVector(eigenVectorOutput, eigen.vector);

          leontiefMeta.textContent = `Computed with order k=${leontief.order}.`;
          eigenMeta.textContent = `Eigenvalue ≈ ${eigen.value.toFixed(8)} | iterations: ${eigen.iterations} | converged: ${eigen.converged}`;
          statusEl.textContent = 'Calculation completed.';
          statusEl.className = 'ok';
        } catch (error) {
          statusEl.textContent = error instanceof Error ? error.message : 'Unknown error';
          statusEl.className = 'error';
        }
      }

      document.getElementById('resize').addEventListener('click', () => {
        const size = clampDimension(Number(dimensionInput.value));
        const old = getMatrixValues();
        dimensionInput.value = String(size);
        const resized = Array.from({ length: size }, (_, r) =>
          Array.from({ length: size }, (_, c) => getValue(old, r, c)),
        );
        renderMatrixInput(size, resized);
      });

      document.getElementById('calculate').addEventListener('click', runCalculations);

      document.getElementById('sample').addEventListener('click', () => {
        const sample = [
          [20, 5, 3],
          [4, 18, 7],
          [2, 6, 15],
        ];
        dimensionInput.value = '3';
        renderMatrixInput(3, sample);
        runCalculations();
      });

      renderMatrixInput(3, [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
      ]);
    </script>
  </body>
</html>
